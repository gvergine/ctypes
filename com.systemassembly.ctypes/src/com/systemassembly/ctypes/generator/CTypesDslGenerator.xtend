/*
 * generated by Xtext 2.18.0.M3
 */
package com.systemassembly.ctypes.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.systemassembly.ctypes.cTypesDsl.DataTypeDef
import com.systemassembly.ctypes.cTypesDsl.StructDef
import com.systemassembly.ctypes.cTypesDsl.StructField

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CTypesDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val modelName = resource.URI.trimFileExtension.lastSegment
		val header_types_filename = modelName + ".h"

		fsa.generateFile(header_types_filename,
			resource.gen_header_types_file)
	
	}
	
	def gen_header_types_file(Resource resource) {
		val dataTypes = resource.allContents.filter(DataTypeDef).toList
	'''
		#pragma once
		
		#include <stdint.h>
		«resource.type_includes»
		
		«FOR dataType : dataTypes SEPARATOR '\n'»
		«IF dataType instanceof StructDef»
		// size of this struct: «dataType.calc_struct_size» bytes
		struct «dataType.name» {
			«FOR field : dataType.fields»
			«field.typedecl»«field.arraydecl» «field.name»;
			«ENDFOR»
		};
		
		typedef struct «dataType.name» «dataType.name»_t;
		
		
		«ENDIF»
		«ENDFOR»
	'''
	}
	
	def int calc_struct_size(StructDef struct) {
		var struct_size = 0
		for (field : struct.fields) {
			var size = 0;
			if (field.basicType !== null) size = sizeof_types_map.get(field.basicType)
			else size = (field.derivedType as StructDef).calc_struct_size
			if (field.arraySize > 0) size = size * field.arraySize;
			struct_size += size		
		}
		return struct_size
	}
	
	def type_includes(Resource resource) {
		var includes = newHashSet
		val derivedTypes = resource.allContents.filter(DataTypeDef).toList
		val structTypes = derivedTypes.filter(StructDef).toList
		for(structType : structTypes)
		{
			for (field: structType.fields)
			{
				if (field.derivedType !== null && field.derivedType instanceof StructDef)
				{
					val foreignResource = field.derivedType.eContainer.eResource
					if (foreignResource != resource)
					{
						includes.add("#include \"" + foreignResource.URI.trimFileExtension.lastSegment + ".h\"")
					}
				}
			}
		}
		return includes.join("\n")
		
	}
	
	def typedecl(StructField field) {
		if (field.basicType !== null) {
			return c_types_map.get(field.basicType)
		} else if (field.derivedType !== null && field.derivedType instanceof StructDef) {
			return (field.derivedType as StructDef).name + '_t';
		} else throw new Exception("Unsupported field type of " + field.name)
	}
	
	def arraydecl(StructField field) {
		if (field.arraySize > 0) {
			return '''[«field.arraySize»]'''
		}
		return ''''''
	}


	val c_types_map = #{
		'int8' -> 'int8_t',
		'int16' -> 'int16_t',
		'int32' -> 'int32_t',
		'int64' -> 'int64_t',
		'uint8' -> 'uint8_t',
		'uint16' -> 'uint16_t',
		'uint32' -> 'uint32_t',
		'uint64' -> 'uint64_t',
		'float' -> 'float',
		'double' -> 'double'
		}
	
	val sizeof_types_map = #{
		'int8' -> 1,
		'int16' -> 2,
		'int32' -> 4,
		'int64' -> 8,
		'uint8' -> 1,
		'uint16' -> 2,
		'uint32' -> 4,
		'uint64' -> 8,
		'float' -> 4,
		'double' -> 8
		}
}